<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A4 Map Generator - Multi Shape</title>

    <!-- PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- PDF Generation Tools -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- QRCode.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <style>
        :root {
            --color-primary: #1a237e;
            --color-primary-light: #534bae;
            --color-background: #eceff1;
            --shadow-1: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
        }

        body {
            background-color: var(--color-background);
            font-family: 'Roboto', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        @media (min-width: 768px) {
            body {
                height: 100vh;
                overflow: hidden;
            }
        }

        /* Inputs */
        .input-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            font-size: 12px;
            font-weight: bold;
            color: #555;
            margin-bottom: 4px;
        }

        textarea,
        select,
        input[type="text"],
        input[type="color"],
        input[type="number"],
        input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Range Slider specific */
        input[type="range"] {
            padding: 0;
            border: none;
            height: 1.5rem;
            cursor: pointer;
        }

        textarea {
            resize: vertical;
            font-family: monospace;
        }

        /* 1行入力のスタイル（Enterキー効くように見えるスタイル） */
        input[type="text"]:focus {
            border-color: var(--color-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(26, 35, 126, 0.1);
        }

        /* Buttons */
        .btn {
            background-color: var(--color-primary);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: var(--shadow-1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            transition: 0.2s;
        }

        .btn:hover:not(:disabled) {
            background-color: var(--color-primary-light);
        }

        .btn:disabled {
            background-color: #9fa8da;
            cursor: not-allowed;
        }

        .btn.secondary {
            background-color: white;
            color: var(--color-primary);
            border: 1px solid #ddd;
        }

        .btn.secondary.active {
            background-color: #e8eaf6;
            border-color: var(--color-primary);
        }

        /* Active State for Drawing Button */
        .btn.active-mode {
            background-color: #f50057;
            /* Pink/Red accent */
            color: white;
            border-color: #f50057;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(245, 0, 87, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(245, 0, 87, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(245, 0, 87, 0);
            }
        }

        .btn-icon-only {
            padding: 4px;
            width: 28px;
            height: 28px;
            min-width: unset;
        }

        /* Layout */
        .main-content {
            display: flex;
            flex: 1;
            flex-direction: column;
        }

        @media (min-width: 768px) {
            .main-content {
                flex-direction: row;
                overflow: hidden;
            }
        }

        /* Preview */
        .preview-container {
            flex-grow: 1;
            background-color: #cfd8dc;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: auto;
            position: relative;
        }

        #scale-wrapper {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.19);
            transform-origin: center center;
            transition: transform 0.3s ease;
        }

        #paper-wrapper {
            background: white;
            width: 210mm;
            height: 297mm;
            padding: 10mm;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
            transition: width 0.3s, height 0.3s;
        }

        #paper-wrapper.landscape {
            width: 297mm;
            height: 210mm;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #eee;
            border: 1px solid #ccc;
            z-index: 1;
        }

        /* Leaflet attribution — PDF変換時の下方向ズレ対策 */
        #map .leaflet-control-attribution {
            font-size: 7px;
            padding: 0px 4px 4px 4px;
            /* 上0 右4 下4 左4: テキストを上寄せ */
            margin: 0;
            line-height: 1.0;
            overflow: visible;
        }

        /* Cursor styles for map interaction */
        .cursor-crosshair {
            cursor: crosshair !important;
        }

        .cursor-grab {
            cursor: grab !important;
        }

        /* Compass */
        .compass-mark {
            position: absolute;
            top: 12mm;
            right: 12mm;
            z-index: 500;
            pointer-events: none;
            filter: drop-shadow(0px 1px 2px rgba(255, 255, 255, 0.8));
        }

        /* Overlays */
        .overlay-box {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            z-index: 400;
            display: none;
        }

        .overlay-box.visible {
            display: block;
        }

        .url-display {
            top: 2mm;
            left: 2mm;
            padding: 2mm;
            font-size: 8px;
        }

        .qr-display {
            top: 10mm;
            left: 2mm;
            padding: 4mm;
        }

        .notes-display {
            bottom: 3mm;
            left: 3mm;
            padding: 3mm;
            font-size: 10px;
            max-width: 50mm;
            white-space: pre-wrap;
        }

        /* Custom Markers for Editing */
        .edit-handle-icon {
            background: white;
            border: 2px solid var(--color-primary);
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .edit-handle-icon:hover {
            background: var(--color-primary);
            border-color: white;
        }

        /* Loading */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 255, 255, 0.95);
            z-index: 9999;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--color-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Hide UI during capture */
        body.capturing header,
        body.capturing aside {
            display: none;
        }

        body.capturing .preview-container {
            padding: 0;
            background: white;
            align-items: flex-start;
            justify-content: flex-start;
            overflow: visible;
        }

        body.capturing #scale-wrapper {
            transform: none !important;
            box-shadow: none;
            margin: 0;
        }

        /* Utility */
        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <header class="bg-[#1a237e] text-white p-3 shadow-md z-10 flex-shrink-0">
        <div class="container mx-auto flex items-center px-2">
            <span class="material-icons mr-2">map</span>
            <h1 class="text-lg font-bold">A4 Map Generator (Multi-Shape)</h1>
        </div>
    </header>

    <div class="main-content">
        <!-- Sidebar -->
        <aside class="w-full md:w-80 bg-white p-4 shadow-lg z-20 overflow-y-auto flex-shrink-0 text-sm">

            <!-- Shape Settings (Moved Top for Mode Selection) -->
            <div class="input-group mb-4">
                <label class="mb-2 text-[#1a237e] flex items-center gap-1 font-bold">
                    <span class="material-icons text-sm">draw</span> 描画モード
                </label>
                <select id="draw-mode">
                    <option value="point" selected>Point (点・中心)</option>
                    <option value="line">Line (線・ルート)</option>
                    <option value="polygon">Polygon (面・エリア)</option>
                </select>
            </div>

            <!-- Coordinates Inputs -->
            <div class="input-group relative">
                <!-- Single Line Input (For Point Mode) -->
                <div id="single-input-container">
                    <label>座標 (緯度, 経度)</label>
                    <input type="text" id="coord-input-single" value="35.012018, 135.767676"
                        placeholder="例: 35.012, 135.767">
                    <div class="text-xs text-gray-400 mt-1">※Enterキーで更新</div>
                </div>

                <!-- Multi Line Input (For Line/Polygon Mode) -->
                <div id="multi-input-container" class="hidden">
                    <!-- Start Drawing Button (Trigger) -->
                    <button id="btn-start-draw" class="btn mb-2">
                        <span class="material-icons">add_location_alt</span> 座標を追加
                    </button>

                    <div class="flex justify-between items-center mb-1">
                        <label class="mb-0">座標リスト</label>
                        <div class="flex gap-1">
                            <button id="btn-center-map"
                                class="btn btn-icon-only bg-gray-200 text-gray-600 hover:bg-green-100 hover:text-green-600 shadow-none border border-gray-300"
                                title="図形の中心に移動">
                                <span class="material-icons text-sm">center_focus_strong</span>
                            </button>
                            <button id="btn-undo-coord"
                                class="btn btn-icon-only bg-gray-200 text-gray-600 hover:bg-blue-100 hover:text-blue-600 shadow-none border border-gray-300"
                                title="ひとつ戻る">
                                <span class="material-icons text-sm">undo</span>
                            </button>
                        </div>
                    </div>
                    <div class="text-xs text-gray-500 mb-1">※地図クリックで座標追加 ／ ダブルクリック・Enter・マップ外クリックで確定</div>
                    <textarea id="coord-input-multi" rows="5"
                        placeholder="35.012, 135.767&#13;&#10;35.013, 135.768"></textarea>
                </div>

                <!-- Google Maps Link -->
                <div class="mt-2">
                    <div class="text-[10px] text-gray-500">
                        *Googleマップから座標をコピーできます。
                    </div>
                    <a id="external-map-link" href="https://www.google.com/maps?q=35.012028,135.767667" target="_blank"
                        class="flex items-center gap-1 text-[10px] text-blue-600 hover:underline mt-1">
                        <span class="material-icons text-[12px]">open_in_new</span>
                        Googleマップで場所を確認
                    </a>
                </div>
            </div>

            <button id="btn-update" class="btn mb-4">
                <span class="material-icons">refresh</span> 地図を更新
            </button>

            <!-- Visual Settings (Lines/Colors) -->
            <div class="border-t border-b border-gray-200 py-3 my-3">
                <div class="grid grid-cols-2 gap-2 mb-2">
                    <div class="input-group mb-0">
                        <label>線の色・塗りつぶし色</label>
                        <input type="color" id="stroke-color" value="#ff0000">
                    </div>
                    <div class="input-group mb-0">
                        <label>線の太さ</label>
                        <input type="number" id="stroke-weight" value="3" min="1" max="20">
                    </div>
                </div>
                <!-- Point Radius Slider -->
                <div id="point-radius-group" class="input-group mb-0">
                    <div class="flex justify-between items-center mb-1">
                        <label class="mb-0">円の大きさ (半径)</label>
                        <span id="radius-display"
                            class="text-xs font-mono font-bold text-blue-800 bg-blue-50 px-2 py-0.5 rounded border border-blue-100">40px</span>
                    </div>
                    <input type="range" id="point-radius" value="40" min="40" max="300" step="1" class="w-full">
                </div>
            </div>

            <!-- Toggles -->
            <div class="space-y-2 mb-4">
                <!-- Center Fix Toggle -->
                <div class="flex items-center justify-between p-2 bg-gray-50 rounded border"
                    id="toggle-fixed-container">
                    <span>マップ移動時に円を中心に固定</span>
                    <input type="checkbox" id="toggle-fixed-marker" checked>
                </div>

                <!-- Vertex Circle Toggle (All Modes) -->
                <div class="flex items-center justify-between p-2 bg-gray-50 rounded border">
                    <span>円(環)を表示</span>
                    <input type="checkbox" id="toggle-show-vertex-circle" checked>
                </div>

                <!-- Center Marker Visibility Toggle (Point Mode Only) -->
                <div id="center-marker-group">
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded border">
                        <span>中心の赤点を表示</span>
                        <input type="checkbox" id="toggle-show-center-marker" checked>
                    </div>
                </div>

                <!-- URL Toggle -->
                <div class="flex items-center justify-between p-2 bg-gray-50 rounded border">
                    <span>URL表示</span>
                    <input type="checkbox" id="toggle-show-url">
                </div>
                <!-- QR Toggle -->
                <div class="flex items-center justify-between p-2 bg-gray-50 rounded border">
                    <span>QRコード表示</span>
                    <input type="checkbox" id="toggle-show-qr">
                </div>
                <div class="text-[10px] text-gray-500 mt-1 px-1" id="qr-note-text">
                    ※URLとQRコードに設定される緯度経度は、赤い円の中心座標
                </div>
            </div>

            <!-- Notes -->
            <div class="input-group">
                <label>備考欄</label>
                <textarea id="notes-input" rows="2" placeholder="備考を入力"></textarea>
            </div>



            <!-- Orientation -->
            <div class="input-group">
                <label>用紙の向き</label>
                <div class="flex gap-2">
                    <button id="btn-portrait" class="btn secondary active w-1/2">縦</button>
                    <button id="btn-landscape" class="btn secondary w-1/2">横</button>
                </div>
            </div>

            <!-- Status -->
            <div id="status-msg" class="text-xs font-bold mb-2 min-h-[1.5em] text-center"></div>

            <!-- Download -->
            <button id="btn-download" class="btn">
                <span class="material-icons">picture_as_pdf</span> PDF保存
            </button>

        </aside>

        <!-- Preview -->
        <main class="preview-container" id="preview-container">
            <div id="scale-wrapper">
                <div id="paper-wrapper">
                    <div class="relative w-full h-full border border-gray-300 bg-gray-100 overflow-hidden">
                        <div id="map"></div>

                        <!-- Compass -->
                        <div class="compass-mark">
                            <svg width="40" height="40" viewBox="0 0 100 100">
                                <circle cx="50" cy="50" r="42" fill="white" stroke="#000" stroke-width="4" />
                                <path d="M50 15 L28 85 L50 70 L72 85 Z" fill="#000" />
                            </svg>
                        </div>

                        <!-- Overlays -->
                        <div id="url-display" class="overlay-box url-display">
                            <a id="url-link" href="#" target="_blank"></a>
                        </div>
                        <div id="qr-display" class="overlay-box qr-display">
                            <div id="qr-code"></div>
                        </div>
                        <div id="notes-display" class="overlay-box notes-display"></div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="spinner mb-4"></div>
        <div class="font-bold text-[#1a237e]">PDF生成中...</div>
    </div>

    <!-- JS Logic -->
    <script>
        let map;
        let drawnLayerGroup;
        let guideLayerGroup;
        let isLandscape = false;
        let currentMode = 'point';
        let isDrawingMode = false;
        let drawingModeStartTime = 0;  // Guard against immediate finishDrawing
        let currentCenter = { lat: 35.012018, lng: 135.767676 };
        // Current coords for overlays
        let currentOverlayCoords = { lat: 35.012018, lng: 135.767676 };



        function initMap() {
            map = L.map('map', {
                zoomControl: false,
                attributionControl: true,
                preferCanvas: true,
                doubleClickZoom: false // Disable default double click zoom
            }).setView([currentCenter.lat, currentCenter.lng], 16);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; OpenStreetMap'
            }).addTo(map);

            drawnLayerGroup = L.layerGroup().addTo(map);
            guideLayerGroup = L.layerGroup().addTo(map);

            // Initial Draw (Point Mode)
            updateMapJS([{ lat: currentCenter.lat, lng: currentCenter.lng }], 'point', {
                color: '#ff0000', weight: 3, fillColor: '#ff0000', fillOpacity: 0.2, radius: 40
            });

            // --- Event Handlers ---

            // Map Click (Add points / Text boxes)
            map.on('click', (e) => {


                const mode = document.getElementById('draw-mode').value;
                const fixed = document.getElementById('toggle-fixed-marker').checked;

                if (mode === 'point') {
                    // In Point mode: Move marker to click location
                    if (!fixed) {
                        const ta = document.getElementById('coord-input-single');
                        ta.value = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
                        // Force update and center
                        updateMapJS([{ lat: e.latlng.lat, lng: e.latlng.lng }], 'point', getStyleSettings(), true);
                        updateOverlays(e.latlng.lat, e.latlng.lng);
                    } else {
                        // If fixed to center, pan map so center is at click
                        map.panTo(e.latlng);
                    }
                } else {
                    // Line/Polygon Mode
                    if (isDrawingMode) {
                        // Add Point
                        addCoordinate(e.latlng);
                    } else {
                        // Not drawing, maybe do nothing or clear selection?
                        // For now, check if user clicked outside map (technically this is map click, so inside)
                    }
                }
            });

            // Double Click to Finish
            map.on('dblclick', (e) => {
                if (isDrawingMode) {
                    addCoordinate(e.latlng);
                    finishDrawing();
                }
            });

            // Mouse Move for Guide Line
            map.on('mousemove', (e) => {
                if (isDrawingMode) {
                    const ta = document.getElementById('coord-input-multi');
                    const lines = ta.value.trim().split('\n');
                    const lastLine = lines[lines.length - 1];

                    if (lastLine) {
                        const parts = lastLine.split(',');
                        if (parts.length >= 2) {
                            const lastLat = parseFloat(parts[0]);
                            const lastLng = parseFloat(parts[1]);

                            guideLayerGroup.clearLayers();
                            L.polyline([[lastLat, lastLng], e.latlng], {
                                color: '#1a237e',
                                weight: 2,
                                dashArray: '5, 10',
                                opacity: 0.6
                            }).addTo(guideLayerGroup);
                        }
                    }
                }
            });

            // Map Move (Sync Single Input in Point + Fixed Mode)
            map.on('move', () => {
                const mode = document.getElementById('draw-mode').value;
                const fixed = document.getElementById('toggle-fixed-marker').checked;

                if (mode === 'point' && fixed) {
                    const center = map.getCenter();
                    const ta = document.getElementById('coord-input-single');
                    ta.value = `${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}`;

                    // Live update marker
                    currentOverlayCoords = { lat: center.lat, lng: center.lng };
                    updateMapJS([{ lat: center.lat, lng: center.lng }], 'point', getStyleSettings());
                    updateOverlays(center.lat, center.lng);
                }
            });

            // Map Move End (Finalize Sync)
            map.on('moveend', () => {
                const mode = document.getElementById('draw-mode').value;
                const fixed = document.getElementById('toggle-fixed-marker').checked;

                if (mode === 'point' && fixed) {
                    const center = map.getCenter();
                    currentOverlayCoords = { lat: center.lat, lng: center.lng };
                    updateOverlays(center.lat, center.lng);
                }
            });

            // Global Key Events
            document.addEventListener('keydown', (e) => {


                if (!isDrawingMode) return;

                // Ignore Enter in textarea (coord-input-multi)
                if (e.target.id === 'coord-input-multi') return;

                if (e.key === 'Enter') {
                    finishDrawing();
                } else if (e.key === 'Escape') {
                    cancelDrawing();
                }
            });

            // Click outside map to finish
            // Exclude: map itself, start-draw button, sidebar (aside), draw-mode selector
            document.body.addEventListener('click', (e) => {
                if (!isDrawingMode) return;
                // Guard: ignore clicks within 300ms of drawing mode start
                if (Date.now() - drawingModeStartTime < 300) return;
                // Ignore clicks inside the map, sidebar, or draw controls
                if (e.target.closest('#map')) return;
                if (e.target.closest('#btn-start-draw')) return;
                if (e.target.closest('aside')) return;
                if (e.target.closest('#draw-mode')) return;
                finishDrawing();
            });

            fitPaperToScreen();
            window.addEventListener('resize', fitPaperToScreen);

            setupUIListeners();
        }

        function getStyleSettings() {
            const color = document.getElementById('stroke-color').value;
            return {
                color: color,
                weight: parseInt(document.getElementById('stroke-weight').value, 10),
                fillColor: color, // Use stroke color
                fillOpacity: 0.2,  // Fixed 20%
                radius: parseInt(document.getElementById('point-radius').value, 10)
            };
        }

        function toggleDrawingMode() {
            isDrawingMode = !isDrawingMode;
            const btn = document.getElementById('btn-start-draw');
            const mapContainer = document.getElementById('map');

            if (isDrawingMode) {
                drawingModeStartTime = Date.now();  // Record start time for guard
                btn.classList.add('active-mode');
                btn.innerHTML = '<span class="material-icons">stop</span> 描画を終了';
                mapContainer.classList.add('cursor-crosshair');
                mapContainer.classList.remove('cursor-grab');
            } else {
                finishDrawing();
            }
        }

        function addCoordinate(latlng) {
            const ta = document.getElementById('coord-input-multi');
            const newCoord = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;

            if (ta.value.trim() === '') {
                ta.value = newCoord;
            } else {
                ta.value = ta.value.trim() + '\n' + newCoord;
            }
            // Auto update map
            document.getElementById('btn-update').click();
        }

        function finishDrawing() {
            if (!isDrawingMode) return;

            isDrawingMode = false;
            guideLayerGroup.clearLayers();

            const btn = document.getElementById('btn-start-draw');
            btn.classList.remove('active-mode');
            btn.innerHTML = '<span class="material-icons">add_location_alt</span> 座標を追加';

            const mapContainer = document.getElementById('map');
            mapContainer.classList.remove('cursor-crosshair');
            mapContainer.classList.add('cursor-grab');

            // Show feedback message
            const statusEl = document.getElementById('status-msg');
            const ta = document.getElementById('coord-input-multi');
            const pointCount = ta.value.trim().split('\n').filter(l => l.trim()).length;
            if (pointCount > 0) {
                statusEl.textContent = `描画を確定しました（${pointCount}点）。再度追加するには「座標を追加」ボタンを押してください。`;
                statusEl.classList.remove('text-red-600');
                statusEl.classList.add('text-green-600');
            }
        }

        function cancelDrawing() {
            finishDrawing();
        }

        // Live Style Update Function
        function updateLiveStyles() {
            const style = getStyleSettings();
            // Update display label
            document.getElementById('radius-display').textContent = style.radius + "px";

            drawnLayerGroup.eachLayer(layer => {
                if (layer instanceof L.CircleMarker) {
                    // Check if it's the center marker (white dot)
                    if (layer.options.color === 'white' && layer.options.radius === 4) return;

                    // Edit Handles (radius 5, white fill)
                    if (layer.options.className === 'edit-handle') {
                        // Keep distinct style
                        return;
                    }

                    // Main Point (Outer Circle)
                    if (layer.options.radius >= 20) { // Assuming outer circle
                        layer.setStyle({
                            color: style.color,
                            weight: style.weight,
                            fill: false,
                            fillOpacity: 0
                        });
                        layer.setRadius(style.radius);
                    }
                }
                else if (layer instanceof L.Polyline || layer instanceof L.Polygon) {
                    layer.setStyle({
                        color: style.color,
                        weight: style.weight,
                        fillColor: style.color, // For Polygon
                        fillOpacity: 0.2
                    });
                }
            });
        }

        window.updateMapJS = function (coordsList, mode, style, forceCenter) {
            if (typeof coordsList === 'string') coordsList = JSON.parse(coordsList);
            if (typeof style === 'string') style = JSON.parse(style);

            drawnLayerGroup.clearLayers();
            currentMode = mode;

            if (!coordsList || coordsList.length === 0) return false;

            // DRAWING LOGIC

            // 1. Draw Geometry (Line/Polygon)
            if (mode === 'line') {
                const latlngs = coordsList.map(c => [c.lat, c.lng]);
                L.polyline(latlngs, { color: style.color, weight: style.weight }).addTo(drawnLayerGroup);
            } else if (mode === 'polygon') {
                const latlngs = coordsList.map(c => [c.lat, c.lng]);
                L.polygon(latlngs, {
                    color: style.color, weight: style.weight,
                    fillColor: style.color, fillOpacity: 0.2
                }).addTo(drawnLayerGroup);
            }

            // 2. Draw Circles and Markers
            if (mode === 'point') {
                coordsList.forEach(c => {
                    const showVertexCircles = document.getElementById('toggle-show-vertex-circle').checked;
                    const showCenterMarkers = document.getElementById('toggle-show-center-marker').checked;

                    // Outer Circle (If enabled)
                    if (showVertexCircles) {
                        L.circleMarker([c.lat, c.lng], {
                            color: style.color, weight: style.weight,
                            fill: false, fillOpacity: 0,
                            radius: style.radius || 40
                        }).addTo(drawnLayerGroup);
                    }

                    // Center Dot (Point Mode Only)
                    if (showCenterMarkers) {
                        L.circleMarker([c.lat, c.lng], {
                            color: 'white', fillColor: style.color, fillOpacity: 1, weight: 1, radius: 4
                        }).addTo(drawnLayerGroup);
                    }
                });
            } else {
                // Line/Poly Mode
                const showVertexCircles = document.getElementById('toggle-show-vertex-circle').checked;

                // ** EDIT HANDLES ** (Draggable Markers)
                coordsList.forEach((c, index) => {
                    const handle = L.marker([c.lat, c.lng], {
                        draggable: true,
                        icon: L.divIcon({
                            className: 'edit-handle-icon', // Custom CSS
                            iconSize: [10, 10],
                            iconAnchor: [5, 5]
                        })
                    }).addTo(drawnLayerGroup);

                    handle.on('dragend', function (e) {
                        const newPos = e.target.getLatLng();
                        updateCoordinateAtIndex(index, newPos);
                    });
                });

                // Calculate Center and Max Distance for Auto Radius
                if (coordsList.length > 0) {
                    const lats = coordsList.map(c => c.lat);
                    const lngs = coordsList.map(c => c.lng);
                    const minLat = Math.min(...lats);
                    const maxLat = Math.max(...lats);
                    const minLng = Math.min(...lngs);
                    const maxLng = Math.max(...lngs);

                    const centerLat = (minLat + maxLat) / 2;
                    const centerLng = (minLng + maxLng) / 2;
                    const centerLatLng = L.latLng(centerLat, centerLng);

                    // AUTO-CALCULATE RADIUS
                    const centerPoint = map.latLngToLayerPoint(centerLatLng);
                    let maxDist = 0;
                    coordsList.forEach(c => {
                        const pt = map.latLngToLayerPoint([c.lat, c.lng]);
                        const dist = centerPoint.distanceTo(pt);
                        if (dist > maxDist) maxDist = dist;
                    });

                    // Add padding and update input
                    const newRadius = Math.ceil(maxDist + 20); // +20px padding

                    const radiusInput = document.getElementById('point-radius');
                    const radiusDisplay = document.getElementById('radius-display');

                    if (newRadius > parseInt(radiusInput.max)) {
                        radiusInput.max = newRadius + 100;
                    }

                    radiusInput.value = newRadius;
                    radiusDisplay.textContent = newRadius + "px";

                    const drawRadius = newRadius;

                    // Draw ONE large circle at the center
                    if (showVertexCircles) {
                        L.circleMarker([centerLat, centerLng], {
                            color: style.color, weight: style.weight,
                            fill: false, fillOpacity: 0,
                            radius: drawRadius
                        }).addTo(drawnLayerGroup);
                    }
                }
            }

            // For Point mode Force Center Logic
            if (mode === 'point' && coordsList.length === 1) {
                const c = coordsList[0];
                const dist = Math.abs(c.lat - map.getCenter().lat) + Math.abs(c.lng - map.getCenter().lng);
                const fixed = document.getElementById('toggle-fixed-marker').checked;

                // Force center if manually updated (forceCenter=true) OR fixed mode
                if (forceCenter || (fixed && dist > 0.00001)) {
                    map.setView([c.lat, c.lng], map.getZoom(), { animate: false });
                }
            }

            if (coordsList.length > 0) {
                currentOverlayCoords = { lat: coordsList[0].lat, lng: coordsList[0].lng };
                updateOverlays(coordsList[0].lat, coordsList[0].lng);
            }
            return true;
        };

        function updateCoordinateAtIndex(index, latlng) {
            const ta = document.getElementById('coord-input-multi');
            const lines = ta.value.trim().split('\n');

            if (index >= 0 && index < lines.length) {
                lines[index] = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
                ta.value = lines.join('\n');

                // Trigger update button to refresh map
                document.getElementById('btn-update').click();
            }
        }

        function updateOverlays(lat, lng) {
            const showUrl = document.getElementById('toggle-show-url').checked;
            const urlBox = document.getElementById('url-display');
            const urlLink = document.getElementById('url-link');

            if (showUrl) {
                const gUrl = `https://www.google.com/maps?q=${lat},${lng}`;
                urlLink.href = gUrl; urlLink.textContent = gUrl;
                urlBox.classList.add('visible');
            } else urlBox.classList.remove('visible');

            const showQr = document.getElementById('toggle-show-qr').checked;
            const qrBox = document.getElementById('qr-display');
            const qrDiv = document.getElementById('qr-code');

            if (showQr) {
                const gUrl = `https://www.google.com/maps?q=${lat},${lng}`;
                qrDiv.innerHTML = '';
                new QRCode(qrDiv, { text: gUrl, width: 80, height: 80 });
                qrBox.classList.add('visible');
            } else qrBox.classList.remove('visible');

            // Update Sidebar Google Map Link
            const extLink = document.getElementById('external-map-link');
            if (extLink) {
                extLink.href = `https://www.google.com/maps?q=${lat},${lng}`;
            }
        }

        function setupUIListeners() {
            // Mode Switching Logic
            const drawMode = document.getElementById('draw-mode');
            const singleContainer = document.getElementById('single-input-container');
            const multiContainer = document.getElementById('multi-input-container');
            const toggleFixedContainer = document.getElementById('toggle-fixed-container');
            const centerMarkerGroup = document.getElementById('center-marker-group');

            drawMode.addEventListener('change', (e) => {
                const mode = e.target.value;
                const singleInput = document.getElementById('coord-input-single');
                const multiInput = document.getElementById('coord-input-multi');

                const qrNoteText = document.getElementById('qr-note-text');
                const toggleVertexCircle = document.getElementById('toggle-show-vertex-circle');

                // Finish any existing drawing session
                finishDrawing();

                if (mode === 'point') {
                    singleContainer.classList.remove('hidden');
                    multiContainer.classList.add('hidden');
                    toggleFixedContainer.classList.remove('hidden');
                    centerMarkerGroup.classList.remove('hidden');
                    qrNoteText.textContent = '※URLとQRコードに設定される緯度経度は、赤い円の中心座標';
                    toggleVertexCircle.checked = true;
                } else {
                    // Line or Polygon
                    singleContainer.classList.add('hidden');
                    multiContainer.classList.remove('hidden');
                    toggleFixedContainer.classList.add('hidden');
                    centerMarkerGroup.classList.add('hidden');
                    qrNoteText.textContent = '※URLとQRコードに設定される緯度経度は、座標リストの1行目となる。';
                    toggleVertexCircle.checked = false; // Auto uncheck for Line/Polygon default
                }

                // Explicitly clear inputs when switching to line/poly
                if (mode !== 'point') {
                    multiInput.value = '';
                    document.getElementById('btn-update').click();
                    // Auto-start drawing mode when switching to line/poly
                    if (!isDrawingMode) {
                        toggleDrawingMode();
                    }
                } else {
                    document.getElementById('btn-update').click();
                }
            });

            // Start Drawing Button
            document.getElementById('btn-start-draw').addEventListener('click', toggleDrawingMode);

            // Undo Button Logic
            document.getElementById('btn-undo-coord').addEventListener('click', () => {
                const ta = document.getElementById('coord-input-multi');
                let val = ta.value.trim();
                if (val) {
                    const lastNewLine = val.lastIndexOf('\n');
                    if (lastNewLine !== -1) {
                        ta.value = val.substring(0, lastNewLine);
                    } else {
                        ta.value = ''; // Only one line, clear it
                    }
                    document.getElementById('btn-update').click();
                }
            });

            // Center Map Logic
            document.getElementById('btn-center-map').addEventListener('click', () => {
                // Logic already embedded in updateMapJS autocalc, but we can force re-center
                // by re-running calculation logic or simply using stored bounds.
                // Simplified: Re-trigger update will re-calc center but not necessarily pan unless logic added.
                // Re-using the logic from previous implementation:
                const val = document.getElementById('coord-input-multi').value.trim();
                if (!val) return;
                const lines = val.split('\n');
                let lats = [], lngs = [];
                lines.forEach(line => {
                    const parts = line.replace(' ', '').replace('　', '').split(',');
                    if (parts.length >= 2) {
                        lats.push(parseFloat(parts[0]));
                        lngs.push(parseFloat(parts[1]));
                    }
                });
                if (lats.length > 0) {
                    const centerLat = (Math.min(...lats) + Math.max(...lats)) / 2;
                    const centerLng = (Math.min(...lngs) + Math.max(...lngs)) / 2;
                    map.panTo([centerLat, centerLng]);
                }
            });

            // Notes
            document.getElementById('notes-input').addEventListener('input', (e) => {
                const el = document.getElementById('notes-display');
                if (e.target.value.trim()) { el.textContent = e.target.value; el.classList.add('visible'); }
                else el.classList.remove('visible');
            });

            // Toggles
            ['toggle-show-url', 'toggle-show-qr'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    updateOverlays(currentOverlayCoords.lat, currentOverlayCoords.lng);
                });
            });

            document.getElementById('toggle-fixed-marker').addEventListener('change', () => {
                // Just force update
            });

            ['toggle-show-center-marker', 'toggle-show-vertex-circle'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    document.getElementById('btn-update').click();
                });
            });

            ['stroke-color', 'stroke-weight', 'point-radius'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateLiveStyles);
            });

            // Orientation
            const setOrient = (land) => {
                isLandscape = land;
                const p = document.getElementById('paper-wrapper');
                p.className = land ? 'landscape' : '';
                document.getElementById('btn-portrait').classList.toggle('active', !land);
                document.getElementById('btn-landscape').classList.toggle('active', land);
                setTimeout(() => { map.invalidateSize(); fitPaperToScreen(); }, 300);
            };
            document.getElementById('btn-portrait').onclick = () => setOrient(false);
            document.getElementById('btn-landscape').onclick = () => setOrient(true);

            // Single Input Enter Key (Force Center)
            document.getElementById('coord-input-single').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('btn-update').click();
                }
            });

            // Single Input Update Button (Force Center)
            document.getElementById('btn-update').addEventListener('click', () => {
                const mode = document.getElementById('draw-mode').value;
                if (mode === 'point') {
                    // Pass true for forceCenter
                    // But we can't pass arguments to click handler directly.
                    // We rely on the python handler calling updateMapJS.
                    // To support "Force Center on Manual Update", we need Python to know.
                    // Alternative: We temporarily set a flag.
                    window._forceCenterNextUpdate = true;
                }
            });


        }

        // Monkey patch window.updateMapJS to check flag
        const originalUpdateMap = window.updateMapJS;
        window.updateMapJS = function (coordsList, mode, style, forceCenter) {
            if (window._forceCenterNextUpdate) {
                forceCenter = true;
                window._forceCenterNextUpdate = false;
            }
            return originalUpdateMap(coordsList, mode, style, forceCenter);
        };

        function fitPaperToScreen() {
            const container = document.getElementById('preview-container');
            const wrapper = document.getElementById('scale-wrapper');
            const paper = document.getElementById('paper-wrapper');
            if (!paper) return;
            const contW = container.clientWidth - 40;
            const contH = container.clientHeight - 40;
            const paperW = paper.offsetWidth;
            const paperH = paper.offsetHeight;
            const scale = Math.min(contW / paperW, contH / paperH, 1.0);
            wrapper.style.transform = `scale(${scale})`;
        }

        window.downloadPDFJS = async function () {
            const overlay = document.getElementById('loading-overlay');
            const paper = document.getElementById('paper-wrapper');
            overlay.style.display = 'flex';
            document.body.classList.add('capturing');
            const c = map.getCenter(); const z = map.getZoom();
            map.invalidateSize(); await new Promise(r => setTimeout(r, 1000));

            try {
                const canvas = await html2canvas(paper, { scale: 2, useCORS: true, allowTaint: true, scrollY: 0 });
                const pdf = new jspdf.jsPDF(isLandscape ? 'l' : 'p', 'mm', 'a4');
                const img = canvas.toDataURL('image/jpeg', 0.8);
                pdf.addImage(img, 'JPEG', 0, 0, isLandscape ? 297 : 210, isLandscape ? 210 : 297);
                if (document.getElementById('toggle-show-url').checked) {
                    const l = document.getElementById('url-link');
                    if (l.href) pdf.link(12, 12, 50, 5, { url: l.href });
                }
                const ts = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '');
                pdf.save(`Map_${ts}.pdf`);
            } catch (e) { alert("Error: " + e.message); }
            finally {
                document.body.classList.remove('capturing'); overlay.style.display = 'none';
                map.invalidateSize(); map.setView(c, z, { animate: false }); fitPaperToScreen();
            }
        };

        document.addEventListener('DOMContentLoaded', initMap);
    </script>

    <!-- Python Logic -->
    <script type="py">
        from pyscript import document
        from js import window, console
        import json

        def get_input_values():
            mode = document.getElementById("draw-mode").value
            
            # Switch reading source based on mode
            if mode == "point":
                text = document.getElementById("coord-input-single").value
            else:
                text = document.getElementById("coord-input-multi").value

            color_val = document.getElementById("stroke-color").value
            radius_val = document.getElementById("point-radius").value
            
            style = {
                "color": color_val,
                "weight": document.getElementById("stroke-weight").value,
                "fillColor": color_val,
                "fillOpacity": 0.2,
                "radius": int(radius_val)
            }
            return text, mode, style

        def parse_coordinates_list(text):
            lines = text.strip().split('\n')
            coords = []
            error = None
            
            for line in lines:
                line = line.strip()
                if not line: continue
                # Sanitize input (handle full-width spaces etc if needed, here simple replace)
                parts = line.replace(' ', '').replace('　', '').split(',')
                if len(parts) >= 2:
                    try:
                        lat = float(parts[0])
                        lng = float(parts[1])
                        coords.append({"lat": lat, "lng": lng})
                    except ValueError:
                        error = f"無効な数値: {line}"
                        break
                else:
                    error = f"形式エラー: {line}"
                    break
            
            if not coords and not error:
                error = "座標を入力してください"
                
            return coords, error

        def on_update_click(event):
            raw_text, mode, style = get_input_values()
            coords_list, error = parse_coordinates_list(raw_text)
            status_el = document.getElementById("status-msg")

            if error:
                status_el.innerText = error
                status_el.classList.add("text-red-600")
                if "入力してください" in error:
                    # Clear map if empty
                    window.updateMapJS("[]", mode, json.dumps(style), True)
            else:
                if mode == "line" and len(coords_list) < 2:
                     status_el.innerText = "線を描くには2つ以上の点が必要です"
                     status_el.classList.add("text-red-600")
                elif mode == "polygon" and len(coords_list) < 3:
                     status_el.innerText = "面を描くには3つ以上の点が必要です"
                     status_el.classList.add("text-red-600")
                else:
                    status_el.innerText = "地図を更新しました"
                    status_el.classList.remove("text-red-600")
                    status_el.classList.add("text-green-600")

                success = window.updateMapJS(json.dumps(coords_list), mode, json.dumps(style), False)

        def on_download_click(event):
            window.downloadPDFJS()

        # Bind Events
        document.getElementById("btn-update").onclick = on_update_click
        document.getElementById("btn-download").onclick = on_download_click
        
    </script>
</body>

</html>